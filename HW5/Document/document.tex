%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Structured General Purpose Assignment
% LaTeX Template
%
% This template has been downloaded from:
% http://www.latextemplates.com
%
% Original author:
% Ted Pavlic (http://www.tedpavlic.com)
%
% Note:
% The \lipsum[#] commands throughout this template generate dummy text
% to fill the template out. These commands should all be removed when 
% writing assignment content.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%----------------------------------------------------------------------------------------
%   PACKAGES AND OTHER DOCUMENT CONFIGURATIONS
%----------------------------------------------------------------------------------------

\documentclass{article}

\usepackage{fancyhdr} % Required for custom headers
\usepackage{lastpage} % Required to determine the last page for the footer
\usepackage{extramarks} % Required for headers and footers
\usepackage{graphicx} % Required to insert images
\usepackage{lipsum} % Used for inserting dummy 'Lorem ipsum' text into the template
\usepackage{amsmath}
\usepackage{xcolor}
\usepackage{listings}
\usepackage[toc,page]{appendix}
\usepackage{algorithm}
\usepackage{algorithmic}

% Margins
\topmargin=-0.45in
\evensidemargin=0in
\oddsidemargin=0in
\textwidth=6.5in
\textheight=9.0in
\headsep=0.25in 

\linespread{1.1} % Line spacing

% Set up the header and footer
\pagestyle{fancy}
\lhead{\hmwkAuthorName} % Top left header
\chead{\hmwkClass\ (\hmwkClassInstructor): \hmwkTitle} % Top center header
\rhead{\firstxmark} % Top right header
\lfoot{\lastxmark} % Bottom left footer
\cfoot{} % Bottom center footer
\rfoot{Page\ \thepage\ of\ \pageref{LastPage}} % Bottom right footer
\renewcommand\headrulewidth{0.4pt} % Size of the header rule
\renewcommand\footrulewidth{0.4pt} % Size of the footer rule

\setlength\parindent{0pt} % Removes all indentation from paragraphs

%----------------------------------------------------------------------------------------
%   DOCUMENT STRUCTURE COMMANDS
%   Skip this unless you know what you're doing
%----------------------------------------------------------------------------------------

% Header and footer for when a page split occurs within a problem environment
\newcommand{\enterProblemHeader}[1]{
    \nobreak\extramarks{#1}{#1 continued on next page\ldots}\nobreak
    \nobreak\extramarks{#1 (continued)}{#1 continued on next page\ldots}\nobreak
}

% Header and footer for when a page split occurs between problem environments
\newcommand{\exitProblemHeader}[1]{
    \nobreak\extramarks{#1 (continued)}{#1 continued on next page\ldots}\nobreak
    \nobreak\extramarks{#1}{}\nobreak
}

\setcounter{secnumdepth}{0} % Removes default section numbers
\newcounter{homeworkProblemCounter} % Creates a counter to keep track of the number of problems
\setcounter{homeworkProblemCounter}{0}

\newcommand{\homeworkProblemName}{}
\newenvironment{homeworkProblem}[1][Problem \arabic{homeworkProblemCounter}]{ % Makes a new environment called homeworkProblem which takes 1 argument (custom name) but the default is "Problem #"
    \stepcounter{homeworkProblemCounter} % Increase counter for number of
% problems
    \renewcommand{\homeworkProblemName}{#1} % Assign \homeworkProblemName the
% name of the problem
    \section{\homeworkProblemName} % Make a section in the document with the
% custom problem count
    \enterProblemHeader{\homeworkProblemName} % Header and footer within the
% environment
}{
    \exitProblemHeader{\homeworkProblemName} % Header and footer after the
% environment
}

\newcommand{\problemAnswer}[1]{ % Defines the problem answer command with the content as the only argument
    \noindent\textbf{\emph{Answer: }}#1 % Just put a keyword Answer in
    % bold/italic at the beginning
}

\newcommand{\homeworkSectionName}{}
\newenvironment{homeworkSection}[1]{ % New environment for sections within homework problems, takes 1 argument - the name of the section
    \renewcommand{\homeworkSectionName}{#1} % Assign \homeworkSectionName to the
% name of the section from the environment argument
    \subsection{\homeworkSectionName} % Make a subsection with the custom name
% of the subsection
    \enterProblemHeader{\homeworkProblemName\ [\homeworkSectionName]} % Header
% and footer within the environment
}{
    \enterProblemHeader{\homeworkProblemName} % Header and footer after the
% environment
}

\newtheorem{theorem}{Theorem}[homeworkProblemCounter]
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{corollary}[theorem]{Corollary}

\newenvironment{proof}[1][Proof]{
    \begin{trivlist}
        \item[\hskip \labelsep {\bfseries #1}]
    }{
        \end{trivlist}
}
\newenvironment{definition}[1][Definition]{
    \begin{trivlist}
        \item[\hskip \labelsep {\bfseries #1}]
    }{
        \end{trivlist}
}
\newenvironment{example}[1][Example]{
    \begin{trivlist}
        \item[\hskip \labelsep {\bfseries #1}]
    }{
        \end{trivlist}
    }
\newenvironment{remark}[1][Remark]{
    \begin{trivlist}
        \item[\hskip \labelsep {\bfseries #1}]
    }{
        \end{trivlist}
}

\newcommand{\qed}{
    \nobreak \ifvmode \relax \else
    \ifdim\lastskip<1.5em \hskip-\lastskip
    \hskip1.5em plus0em minus0.5em \fi \nobreak
    \vrule height0.75em width0.5em depth0.25em\fi
}

\lstset{
    frame=single,
    breaklines=true,
    postbreak=\raisebox{0ex}[0ex][0ex]{\ensuremath{\color{red}\hookrightarrow\space}}
}
   
%----------------------------------------------------------------------------------------
%   NAME AND CLASS SECTION
%----------------------------------------------------------------------------------------

\newcommand{\hmwkTitle}{Assignment\ \#5} % Assignment title
\newcommand{\hmwkDueDate}{Tuesday,February\ 26,\ 2015} % Due date
\newcommand{\hmwkClass}{ECS\ 222A} % Course/class
\newcommand{\hmwkClassTime}{TR 4:40pm-6:00pm} % Class/lecture time
\newcommand{\hmwkClassInstructor}{Daniel Gusfield} % Teacher/lecturer
\newcommand{\hmwkAuthorName}{Wenhao Wu} % Your name

%----------------------------------------------------------------------------------------
%   TITLE PAGE
%----------------------------------------------------------------------------------------

\title{
    \vspace{2in}
    \textmd{\textbf{\hmwkClass:\ \hmwkTitle}}\\
    \normalsize\vspace{0.1in}\small{Due\ on\ \hmwkDueDate}\\
    \vspace{0.1in}\large{\textit{\hmwkClassInstructor\ \hmwkClassTime}}
    \vspace{3in}
}

\author{\textbf{\hmwkAuthorName}}
\date{} % Insert date here if you want it to appear below your name

%----------------------------------------------------------------------------------------

\begin{document}

    \maketitle
    
    %----------------------------------------------------------------------------------------
    %   TABLE OF CONTENTS
    %----------------------------------------------------------------------------------------
    
    %\setcounter{tocdepth}{1} % Uncomment this line if you don't want subsections listed in the ToC
    
    \newpage
    \tableofcontents
    \newpage

    %----------------------------------------------------------------------------------------
    %   PROBLEM 1
    %----------------------------------------------------------------------------------------
    \begin{homeworkProblem}
        Read (or skim, since we discussed it in class) the first 4 sections of
        the Bender et al. paper on the LCA problem. In class we derived a
        preprocessing time of $O(\sqrt{n}\times(\log_2n)^3)$ to build the
        tables for all the binary vectors. In the Bender paper, the time stated
        for that is faster by a factor of $(\log_2 n)$. How do they achieve
        this improvement? (This is an easy problem given what we have already
        done in this class, but it makes sure you understand the method.)
        
        \vspace{10pt}
        \problemAnswer{
            As discussed in the class, the bottleneck in the
            preprocessing is, for each of the $\sqrt{n}/2$ possible binary
            vector of length $\log_2n/2 - 1$ named $b$, where
            $b[i]\in\{-1,1\}$, $i = 1,\ldots,\log_2n/2 - 1$, compute
            \begin{align}
                (\phi_b(u,v), \eta_b(u,
                v)) = \left(\min_{j\in[u,v]}\sum_{i=0}^{j-1}b[i],
                \arg\min_{j\in[u,v]}\sum_{i=0}^{j-1}b[i])\right), 1\leq u\leq
                v \leq \log_2n/2
            \end{align}
            in which we define $b[0] = 0$. In the original preprocessing method,
            the computation of each $(\phi_b(u,v), \eta_b(u,v))$ with a linear
            scan takes $O(\log_2 n)$ time. However, all $(\phi_b(u,v),
            \eta_b(u,v))$ can in fact be computed using dynamic programming.
            Specifically, define
            \begin{align}
                \rho_b(v) = \sum_{i=0}^{v-1}b[i],
            \end{align}
            we have the recursion
            \begin{subequations}
                \begin{align}
                    \rho_b(v+1) & = \rho_b(v) + b[v+1] \\
                    \phi_b(u, v+1) & = \min\{\phi_b(u, v),\rho_b(v+1)\} \\
                    \eta_b(u, v+1) & = \left\{\begin{array}{ll}\eta_b(u,
                    v) & \mbox{if } \phi_b(u, v) < \rho_b(v+1)
                    \\ v+1 & \mbox{else.}\end{array}\right.
                \end{align}
            \end{subequations}
            and the base cases are
            \begin{subequations}
                \begin{align}
                    \rho_b(0) & = 0 \\
                    \phi_b(u,u) & = b[u] \\
                    \eta_b(u, u) & = u
                \end{align}
            \end{subequations}
            In the DP, we can compute all $(\phi_b(u,u+d),\eta_b(u,u+d))$, $u =
            1, \ldots, \log_2n/2$ by increaseing $d$ by 1 each time. In this
            way, the time to compute all $(\phi_b(u,v), \eta_b(u,v))$ is
            $O((\log_2n)^2)$ for each $b$. Consequently, the overall
            preprocessing time is $O(\sqrt{n}(\log_2n)^2)$, which is $\log_2n$
            faster than the linear scan method.
            
        }
        
    \end{homeworkProblem}
    
    %----------------------------------------------------------------------------------------
    %   PROBLEM 2
    %----------------------------------------------------------------------------------------
    \begin{homeworkProblem}
        Now, read Section 5 of the LCA paper of Bender et al. In that paper,
        they call the Range Query problem that we discussed in class (where the
        list $L$ comes from a tree) the +-1RMQ problem. In section 5, they show
        how to solve the general RMQ problem (where the consecutive values can
        differ by any amount). They show that the general RMQ problem can be
        solved in constant time, after $O(n)$ preprocessing, i.e., just as fast
        as the +-1RMQ. This is done by reducing the general RMQ problem to an
        LCA problem on a tree, in $O(n)$ time. Call LCA problem that the RMQ
        problem reduces to, the RLCA problem, and use $RT$ to refer to the tree
        used in the RLCA problem.
        
        \begin{homeworkSection}{\homeworkProblemName(a)}
            Is this an amazing result, or what? I mean, the fact that any LCA
            query can be answered in constant time, after only linear-time
            preprocessing, is already amazing, but probably one would
            (hand-waivingly) explain that it is somehow due to the fact that
            the adjacent $L$ values differ by +1 or -1, which allows a
            4-Russian’s approach. But, then to see that in fact, that condition
            is not needed \ldots
            
            \vspace{10pt}
            \problemAnswer{
                Yes. The key point is that one can transform a general RMQ
                problem into a LCA problem by building a Cartesian Tree with
                $O(n)$ amortized complexity.
                
            }
        \end{homeworkSection}
        
        \begin{homeworkSection}{\homeworkProblemName(b)}
            In class, we said that in some applications, only the LCAs of two
            leaves of a tree $T$ are ever needed. In this true of the $RT$ trees
            used to solve RLCA problems, in order to solve general RMQ problems?
            (This is also an easy problem, only really intended to be sure you
            read and understood Section 5.)
            
            \vspace{10pt}
            \problemAnswer{
                This is not likely to be true. In the general RMQ problem
                one might ask for the smallest element in the subarray
                $A[i,\ldots,j]$ for any pair of indices $(i, j)$. However, in
                the RT tree, the nodes corresponding to indices $i$ and $j$ may
                not be leaf nodes. This indicates that solving LCA problem only
                for 2 leaf nodes for the RT trees constructed is not sufficient
                to solve general RMQ problems.
                
             }
        \end{homeworkSection}
    \end{homeworkProblem}
    
    %----------------------------------------------------------------------------------------
    %   PROBLEM 3
    %----------------------------------------------------------------------------------------
    \begin{homeworkProblem}
        Read (or skim, since we have already discussed it in class) the Wagner
        paper on global minimum cut in an undirected graph.
        
        \begin{homeworkSection}{\homeworkProblemName(a)}
            In the last sentence of Section 2, they state: 
            \begin{quotation}
                ``Notice that the starting vertex a stays the same throughout
                the whole algorithm. It can be selected arbitrarily in each phase
                instead.''
            \end{quotation}
            
            Make an explicit argument for this claim.
            
            \vspace{10pt}
            \problemAnswer{
                According to Theorem 2.1. in Section 2, the generic algorithm
                from the lecture works if we can find any pair $s-t$ cut during
                each of the $n-1$ iterations (phases) and then merge them. Since
                during each iteration, selecting arbitrary starting vertex
                eventually will result in some min $s-t$ cut, the starting point
                does not have to stay the same.
             }
        \end{homeworkSection}
        
        \begin{homeworkSection}{\homeworkProblemName(b)}
            It is known that in any edge-weighted undirected graph with $n$
            nodes, there is a set $S$ of at most $n − 1$ cuts (bipartitions of
            the nodes), such that for any pair of nodes $s, t$ (there are
            $\left(\begin{array}{l}n\\2\end{array}\right)$ pairs of
            nodes), $S$ will contain a minimum $s − t$ cut.

            Do the $n − 1$ minimum cuts found by the Wagner algorithm form such
            a set $S$? Prove that they do, or find a counter-example.
            
            \vspace{10pt}
            \problemAnswer{
                Look at the example provided in Wagner's paper. The 7 cuts are
                \begin{enumerate}
                    \item $\{1\}, \{2, 3, 4, 5, 6, 7, 8\}$, with $w=5$;
                    \item $\{8\}, \{1, 2, 3, 4, 5, 6, 7\}$, with $w=5$;
                    \item $\{7, 8\}, \{1, 2, 3, 4, 5, 6\}$, with $w=7$;
                    \item $\{4, 7, 8\}, \{1, 2, 3, 5, 6\}$, with $w=7$;
                    \item $\{3, 4, 7, 8\}, \{1, 2, 5, 6\}$, with $w=4$;
                    \item $\{1, 5\}, \{2, 3, 4, 6, 7, 8\}$, with $w=7$;
                    \item $\{2\}, \{1, 3, 4, 5, 6, 7, 8\}$, with $w=9$.
                \end{enumerate} 
                However, we can find the $5-6$ cut $\{1, 2, 3, 4, 5, 7, 8\}$,
                $\{6\}$ with $w=6$ which is smaller than all the $5-6$ cut in
                the above list. This serves as a counter example indicating that
                the Wagner algorithm does not form such a set $S$.
                
            }
        \end{homeworkSection}
    \end{homeworkProblem}
    %\clearpage
    
    %----------------------------------------------------------------------------------------
    %   PROBLEM 4
    %----------------------------------------------------------------------------------------
    \begin{homeworkProblem}
        Parametric P-P problem (this is probably the most time-consuming
        problem, but it mostly requires that you understand the Preflow-Push
        method.)
        
        Recall that in HW 4, you showed that if $f$ is some non-maximum $s-t$
        flow in a graph $G$, and $G_f$ is the residual flow graph with respect
        to $f$, then a maximum $s-t$ flow in $G$ can be obtained by
        superimposing $f$ with the maximum $s-t$ flow $g$ in $G_f$.
        
        Suppose one wants to compute a sequence of $k$ maximum $s-t$ flows in a
        graph $G$, where between each flow computation the capacity on each edge
        out of $s$ is either unchanged or increased, and all other capacities
        are left constant. We call this a parametric flow problem. There are
        many problems which can be solved by such a sequence of flow
        computations. If we consider each flow as an independent computation,
        the best resulting time bound is $O(kn^3)$.
        
        \begin{homeworkSection}{\homeworkProblemName(a)}
            Using the result from HW 4, restated above, give a brief argument
            that the $(i+1)$ $s-t$ flow can be computed by changing the
            capacities on the edges out of $s$ in the last residual graph
            used in the $i$-th maximum flow computation, and then finding the
            maximum flow in that altered residual graph. Essentially, then we
            are computing the $(i + 1)$ $s-t$ flow, starting with the $i$-th
            flow in the $(i + 1)$ $s-t$ graph.
            
            \vspace{10pt}
            \problemAnswer{
                Firstly, we note that the $i$-th $s-t$ flow is still a flow in
                the $(i+1)$-th graph, since the conservation at all nodes are
                still satisfied and 
                \begin{align}
                    0\leq f_i(u, v) \leq c_i(u, v) \leq c_{i+1}(u, v) 
                \end{align}
                Secondly, given $f_i(u, v)$, in the altered residual graph, the
                only edges whose capacities are potentially changed are
                \begin{align}
                    c_i^f(s, v) = c_i(s, v) - f_i(s, v) \longrightarrow
                    c_{i+1}^f(s, v) = c_{i+1}(s, v) - f_i(s, v),\,v\in V
                \end{align}
                i.e. only the forward edge from $s$ is altered in the residual
                graph. Consequently, according to HW4, to compute the $(i+1)-th$
                max $s-t$ flow, we just need to change the capacities on the
                edges out of $s$ in the last residual graph used in the $i$-th
                maximum flow computation, and then finding the maximum flow in
                that altered residual graph.
                
            }
        \end{homeworkSection}
        
        \begin{homeworkSection}{\homeworkProblemName(b)}
            Now we explore how the variant of the Preflow-Push algorithm which
            always picks the active node with largest $d$ value works in this
            parametric environment.
            
            Argue that the following method correctly computes the $i + 1$ $s-t$
            maximum flow in the sequence.
            \begin{enumerate}
                \item In the last residual graph used by the Preflow-Push
                algorithm in the $i$-th flow computation, remove all edges into
                $s$, and remove every node, other than s, whose $d$ label is $n$
                or greater. Leave all of the node labels $d$ on the remaining
                nodes unchanged. Call this graph $G'$.
                \item Increase the capacities (as given by the new capacity
                data) of every edge of $G'$ out of $s$ to a remaining node in
                $G'$. This might create new forward edges. Call this graph
                $G''$.
                \item Saturate all the edges in $G''$ out of $s$.
                \item With this preflow, and the existing $d$ labels, continue
                with the preflow-push algorithm, with the maximum $d$ variant,
                on $G''$. When it stops, superimpose its flow with the flow
                for the $i$-th problem in the sequence. We claim that this gives
                a maximum flow in the $i + 1$ $s-t$ graph in the sequence.
            \end{enumerate}
            The key to proving that this is correct is to first show that Step 3
            does indeed create a preflow in $G''$, and the node labels are
            valid for that preflow. After that, you only need to briefly argue
            that the overall algorithm is correct.
            
            \vspace{10pt}
            \problemAnswer{
                \begin{lemma}
                    In the above algorithm, Step 3 does indeed create a preflow
                    in $G''$ and the node labels are valid fo that preflow.
                \end{lemma}
                \begin{proof}
                    Firstly we show that Step 3 creates a preflow in $G''$.
                    Denote the node set in $G'$ and $G''$ as $V'$ the edge set
                    in $G''$ as $E_f''$, and the capacity of edge $(u, v)$
                    in $G''$ as $c_f''(u, v)$, then
                    \begin{itemize}
                        \item For each node $v$ in $\{v| (s, v)\in E_f'', v\in
                        V'\backslash\{s\}\}$, after Step 3, we have $f(v, u) =
                        0$ for all $u\in V'$, $f(s, v) = c_f''(s, v)$ and $f(u,
                        v) = 0$ for $u\not=s$. Consequently, the excess of $v$ is
                        \begin{align}
                            e(v) & = \sum_{v\in V'} f(v, u) - \sum_{v\in V'}f(u,
                            v) \notag \\
                            & = c_f''(s, v)
                        \end{align}
                        \item For each node $v$ in $\{v| (s, v)\notin E_f'', v\in
                        V'\backslash\{s\}\}$, i.e. there is no edge from $s$ to
                        $v$ in $G''$, we have $f(v, u) = f(u, v) = 0$ all $u\in
                        V'$. Consequently, the excess of $v$ is
                        \begin{align}
                            e(v) & = \sum_{v\in V'} f(v, u) - \sum_{v\in V'}f(u,
                            v) \notag \\
                            & = 0
                        \end{align}
                    \end{itemize}
                    In summary, for any $u, v \in V'$, we have $0\leq f(u,
                    v)\leq c_f''(u, v)$ and for all $v\in V'\backslash\{s\}$ we
                    have $e(v) \geq 0$, therefore after Step 3 there is indeed a
                    preflow in $G''$.
                    
                    Next we show that after Step 3 the node labels are valid.
                    For all the remaining nodes in $G''$ their node labels are
                    the same as in $G_f$ the original residual graph used by the
                    Preflow-Push algorithm. Denote the capacity of edge $(u, v)$
                    in $G'$ as $c_f'(u, v)$. In graph $G''$, for all $c_f''(u,
                    v) > 0$, we must have $u\not=s$ since after Step 3 all edges
                    $(s, v)$ must have been satisfied. Since $u\not=s$, from
                    Step 1 we know that $v\not=s$, concequently, edge $(u, v)$
                    must be in the original residual graph. Thus
                    \begin{align}
                        d(v) \leq d(u) + 1 
                    \end{align}
                    in the original residual graph. Since in $G''$ the labels of
                    the remaining nodes are not changed, the labels are also
                    valid in $G''$
                    
                \end{proof}
                
                Since the flow from running the max-$d$ algorithm on $G''$
                serves as a maximum flow in te $i+1$-th altered residual graph.
                According to Problem 4(a), the overall algorithm results in the
                maximum $s-t$ flow in the $(i+1)$-th graph.
                
            }
        \end{homeworkSection}
        
        \vspace{10pt}
        So far, we haven’t made much progress, since the time for each running
        of the above algorithm is bounded only by $O(n^3)$. But, I believe that
        the entire sequence of $k$ flows can be computed in $O(n^3 + kn)$ time,
        which is a dramatic improvement over the method that starts each flow
        from scratch. We will explore this in the next homework (or you can get
        started now).
    \end{homeworkProblem}
    %\clearpage
    
    %----------------------------------------------------------------------------------------

\end{document}