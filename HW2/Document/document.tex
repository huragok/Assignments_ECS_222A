%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Structured General Purpose Assignment
% LaTeX Template
%
% This template has been downloaded from:
% http://www.latextemplates.com
%
% Original author:
% Ted Pavlic (http://www.tedpavlic.com)
%
% Note:
% The \lipsum[#] commands throughout this template generate dummy text
% to fill the template out. These commands should all be removed when 
% writing assignment content.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%----------------------------------------------------------------------------------------
%	PACKAGES AND OTHER DOCUMENT CONFIGURATIONS
%----------------------------------------------------------------------------------------

\documentclass{article}

\usepackage{fancyhdr} % Required for custom headers
\usepackage{lastpage} % Required to determine the last page for the footer
\usepackage{extramarks} % Required for headers and footers
\usepackage{graphicx} % Required to insert images
\usepackage{lipsum} % Used for inserting dummy 'Lorem ipsum' text into the template
\usepackage{amsmath}
\usepackage{xcolor}
\usepackage{listings}
\usepackage[toc,page]{appendix}
\usepackage{algorithm}
\usepackage{algorithmic}

% Margins
\topmargin=-0.45in
\evensidemargin=0in
\oddsidemargin=0in
\textwidth=6.5in
\textheight=9.0in
\headsep=0.25in 

\linespread{1.1} % Line spacing

% Set up the header and footer
\pagestyle{fancy}
\lhead{\hmwkAuthorName} % Top left header
\chead{\hmwkClass\ (\hmwkClassInstructor): \hmwkTitle} % Top center header
\rhead{\firstxmark} % Top right header
\lfoot{\lastxmark} % Bottom left footer
\cfoot{} % Bottom center footer
\rfoot{Page\ \thepage\ of\ \pageref{LastPage}} % Bottom right footer
\renewcommand\headrulewidth{0.4pt} % Size of the header rule
\renewcommand\footrulewidth{0.4pt} % Size of the footer rule

\setlength\parindent{0pt} % Removes all indentation from paragraphs

%----------------------------------------------------------------------------------------
%	DOCUMENT STRUCTURE COMMANDS
%	Skip this unless you know what you're doing
%----------------------------------------------------------------------------------------

% Header and footer for when a page split occurs within a problem environment
\newcommand{\enterProblemHeader}[1]{
    \nobreak\extramarks{#1}{#1 continued on next page\ldots}\nobreak
    \nobreak\extramarks{#1 (continued)}{#1 continued on next page\ldots}\nobreak
}

% Header and footer for when a page split occurs between problem environments
\newcommand{\exitProblemHeader}[1]{
    \nobreak\extramarks{#1 (continued)}{#1 continued on next page\ldots}\nobreak
    \nobreak\extramarks{#1}{}\nobreak
}

\setcounter{secnumdepth}{0} % Removes default section numbers
\newcounter{homeworkProblemCounter} % Creates a counter to keep track of the number of problems
\setcounter{homeworkProblemCounter}{-1}

\newcommand{\homeworkProblemName}{}
\newenvironment{homeworkProblem}[1][Problem \arabic{homeworkProblemCounter}]{ % Makes a new environment called homeworkProblem which takes 1 argument (custom name) but the default is "Problem #"
    \stepcounter{homeworkProblemCounter} % Increase counter for number of
% problems
    \renewcommand{\homeworkProblemName}{#1} % Assign \homeworkProblemName the
% name of the problem
    \section{\homeworkProblemName} % Make a section in the document with the
% custom problem count
    \enterProblemHeader{\homeworkProblemName} % Header and footer within the
% environment
}{
    \exitProblemHeader{\homeworkProblemName} % Header and footer after the
% environment
}

\newcommand{\problemAnswer}[1]{ % Defines the problem answer command with the content as the only argument
    \noindent\textbf{\emph{Answer: }}#1 % Just put a keyword Answer in
    % bold/italic at the beginning
}

\newcommand{\homeworkSectionName}{}
\newenvironment{homeworkSection}[1]{ % New environment for sections within homework problems, takes 1 argument - the name of the section
    \renewcommand{\homeworkSectionName}{#1} % Assign \homeworkSectionName to the
% name of the section from the environment argument
    \subsection{\homeworkSectionName} % Make a subsection with the custom name
% of the subsection
    \enterProblemHeader{\homeworkProblemName\ [\homeworkSectionName]} % Header
% and footer within the environment
}{
    \enterProblemHeader{\homeworkProblemName} % Header and footer after the
% environment
}

\newtheorem{theorem}{Theorem}[homeworkProblemCounter]
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{corollary}[theorem]{Corollary}

\newenvironment{proof}[1][Proof]{
    \begin{trivlist}
        \item[\hskip \labelsep {\bfseries #1}]
    }{
        \end{trivlist}
}
\newenvironment{definition}[1][Definition]{
    \begin{trivlist}
        \item[\hskip \labelsep {\bfseries #1}]
    }{
        \end{trivlist}
}
\newenvironment{example}[1][Example]{
    \begin{trivlist}
        \item[\hskip \labelsep {\bfseries #1}]
    }{
        \end{trivlist}
    }
\newenvironment{remark}[1][Remark]{
    \begin{trivlist}
        \item[\hskip \labelsep {\bfseries #1}]
    }{
        \end{trivlist}
}

\newcommand{\qed}{
    \nobreak \ifvmode \relax \else
    \ifdim\lastskip<1.5em \hskip-\lastskip
    \hskip1.5em plus0em minus0.5em \fi \nobreak
    \vrule height0.75em width0.5em depth0.25em\fi
}

\lstset{
    frame=single,
    breaklines=true,
    postbreak=\raisebox{0ex}[0ex][0ex]{\ensuremath{\color{red}\hookrightarrow\space}}
}
   
%----------------------------------------------------------------------------------------
%	NAME AND CLASS SECTION
%----------------------------------------------------------------------------------------

\newcommand{\hmwkTitle}{Assignment\ \#1} % Assignment title
\newcommand{\hmwkDueDate}{Tusday,\ January\ 13,\ 2015} % Due date
\newcommand{\hmwkClass}{ECS\ 222A} % Course/class
\newcommand{\hmwkClassTime}{TR 4:40pm-6:00pm} % Class/lecture time
\newcommand{\hmwkClassInstructor}{Daniel Gusfield} % Teacher/lecturer
\newcommand{\hmwkAuthorName}{Wenhao Wu} % Your name

%----------------------------------------------------------------------------------------
%	TITLE PAGE
%----------------------------------------------------------------------------------------

\title{
    \vspace{2in}
    \textmd{\textbf{\hmwkClass:\ \hmwkTitle}}\\
    \normalsize\vspace{0.1in}\small{Due\ on\ \hmwkDueDate}\\
    \vspace{0.1in}\large{\textit{\hmwkClassInstructor\ \hmwkClassTime}}
    \vspace{3in}
}

\author{\textbf{\hmwkAuthorName}}
\date{} % Insert date here if you want it to appear below your name

%----------------------------------------------------------------------------------------

\begin{document}

    \maketitle
    
    %----------------------------------------------------------------------------------------
    %	TABLE OF CONTENTS
    %----------------------------------------------------------------------------------------
    
    %\setcounter{tocdepth}{1} % Uncomment this line if you don't want subsections listed in the ToC
    
    \newpage
    \tableofcontents
    \newpage

    %----------------------------------------------------------------------------------------
    %	PROBLEM 0
    %----------------------------------------------------------------------------------------
    \begin{homeworkProblem}
        In the bit-model every bit-level operation must be counted. For example,
        to take the OR of two binary strings of length $q$ each, takes $q$
        operations, and to use or set an index consisting of $q$ bits, takes $q$
        operations. Show in detail that in the bit-model, then the 4-Russianâ€™s
        method for bitmatrix multiplication only takes $\mathcal{O}(n^3/(\log
        n))$ operations.
        
        \problemAnswer{
            The steps of 4-Russian's method for bitmatrix multiplication (BMM)
            are summarized in Algorithm~\ref{alg:4russians}.
            \begin{algorithm}
                \caption{4-Russian's algorithm for BMM of $n\times n$ bit matrix
                $A$ and $B$: C = AB}
                \label{alg:4russians}
                \begin{algorithmic}[1]
                    \STATE Define $k = \log_4 n$. Build a $2^k\times 2^k$ look
                    up tables $T$. $T(u, v)$ in which $u = 0,\ldots,2^k - 1$ and
                    $v = 0,\ldots,2^k-1$ is the multiplication between
                    the row bit vector representing $i$ and the column vit
                    vector representing $j$.
                    \FOR {i = 1 \TO n}
                        \FOR {j = 1 \TO n}
                            \STATE Divide $A$'s $i$-th row $A_{i,:}$ into $n/k$
                            row vectors of length $k$, denoted as
                            $A_{i,:}^{(1)}, \ldots, A_{i,:}^{(n/k)}$. Similarly,
                            divide $B$'s $j$-th row $B_{:, j}$ into $n/k$ column
                            vectors of length $k$, denoted as $B_{:,j}^{(1)},
                            \ldots, B_{:,j}^{(n/k)}$.
                            \STATE Lookup the multiplication value
                            $A_{i,:}^{(w)}B_{:,j}^{(w)}, w = 1,\ldots, n/k$, 
                            from table $T$.
                            \STATE Take the OR operation of all
                            $A_{i,:}^{(w)}B_{:,j}^{(w)}, w = 1,\ldots, n/k$ as
                            the result $C_{ij}$.
                        \ENDFOR
                    \ENDFOR
                \end{algorithmic}
            \end{algorithm}
            
            In line 1, to build the $2^k\times 2^k = \sqrt{n} \times
            \sqrt{n}$ lookup table, according to the matrix multiplication
            definition, it takes $\mathcal{O}(n^{3/2})$ operations
            
            In line 5, given $(i, j)$, for each $w$ it takes
            $\mathcal{O}(k)$ to index the table $T$, so the total number of cost
            of index is $\mathcal{O}(\log_4 n)$.
            
            In line 6, given $(i, j)$, the sum-OR takes
            $\mathcal{O}(n/k) = \mathcal{O}(n/\log_4 n)$ operations.
            
            Consequently, the total number of operations is 
            \[
                \mathcal{O}(n^{3/2}) + n^2(\mathcal{O}(\log_4 n) +
                \mathcal{O}(n/\log_4 n)) = \mathcal{O}(n^3/(\log(n)))
            \]
        
        }
    \end{homeworkProblem}
    
    %----------------------------------------------------------------------------------------
    %   PROBLEM 1
    %----------------------------------------------------------------------------------------
    \begin{homeworkProblem}
        Prove that the edit distance is the same no matter which definition is
        used.
        
        \problemAnswer{
            In order to change both $S_1$ and $S_2$ into a same string (no
            matter what exactly this string is), given a position $p_1$ in $S_1$
            and position $p_2$ in $S_2$, we need to carry out some operation
            either at $p_1$ or $p_2$ (but not both) so that after the operation
            the charactors on this two positions are matched. In this sense the
            following pairs of operations are equivalent:
            \begin{itemize}
                \item Insertion in $S_1$ and deletion in $S_2$.
                \item Deletion in $S_1$ and insertion in $S_2$.
                \item Replacement in $S_1$ and replacement in $S_2$.
            \end{itemize}
            We can see that for each of the 3 allowed operation on 1 string,
            there is an equivalent operation on the other string that has the
            same effect (get a match in the current position). Therefore, the
            edit distance is the same no matter which definition is used.
        }
    \end{homeworkProblem}
    
    %----------------------------------------------------------------------------------------
    %   PROBLEM 2
    %----------------------------------------------------------------------------------------
    \begin{homeworkProblem}
        From the mathematical standpoint, an alignment and an edit transcript
        are equivalent ways to describe a relationship between two strings. An
        alignment can be easily converted to the equivalent edit transcript and
        vice-versa.  Completely explain and justify the above statement.
        
        \problemAnswer{
            The algorithm to convert an alignment to an edit transcript is shown
            in Algorithm~\ref{alg:ali2trans}.
            \begin{algorithm}
                \caption{Convert an alignment $(S_1', S_2'$) to an edit
                transcript $E$.}
                \label{alg:ali2trans}
                \begin{algorithmic}[1]
                    \FOR {i = 1 \TO length($S_1'$)}
                        \IF{$S_1'[i] == S_2'[i]$}
                            \STATE $E[i] = \mbox{M}$
                        \ELSIF {$S_1'[i] = \_$}
                            \STATE $E[i] = \mbox{I}$
                        \ELSIF {$S_2'[i] = \_$}
                            \STATE $E[i] = \mbox{D}$
                        \ELSE
                            \STATE $E[i] = \mbox{R}$
                        \ENDIF
                    \ENDFOR
                \end{algorithmic}
            \end{algorithm}
            
            The algorithm to convert an edit transcript to an alignment is
            shown in Algorithm~\ref{alg:trans2ali}.
            \begin{algorithm}
                \caption{Convert an edit transcript $E$ and the
                original strings $(S_1, S_2)$ to an alignment $(S_1', S_2'$).}
                \label{alg:trans2ali}
                \begin{algorithmic}[1]
                    \STATE Initialize pointer $p_1$ to the beginning of
                    $S_1$, $p_2$ to the beginning of $S_2$, $e$ to the
                    beginning of $E$, and $a$ to the beginning of the alignment
                    $S_1', S_2'$.
                    \REPEAT
                        \IF {$E[e] = \mbox{M}$ \textbf{or} $E[e] = \mbox{R}$} 
                            \STATE $S_1'[a] = S_1[p_1]$, $S_2'[a] = S_2[p_2]$.
                            \STATE $e += 1$, $p_1 += 1$, $p_2 += 1$, $a += 1$.
                        \ELSIF {$E[e] = \mbox{I}$}
                            \STATE $S_1'[a] = \_$, $S_2'[a] = S_2[p_2]$.
                            \STATE $e += 1$, $p_2 += 1$, $a += 1$.
                        \ELSE
                            \STATE $S_1'[a] = S_1[p_1]$, $S_2'[a] = \_$.
                            \STATE $e += 1$, $p_1 += 1$, $a += 1$.
                        \ENDIF
                    \UNTIL{$p_1$ at the end of $S_1$ \textbf{and} $p_2$ at
                    the end of $S_2$}
                \end{algorithmic}
            \end{algorithm}
        }
    \end{homeworkProblem}
    
    %----------------------------------------------------------------------------------------
    %   PROBLEM 3
    %----------------------------------------------------------------------------------------
    \begin{homeworkProblem}
        Prove that any traceback path specifies an optimal edit transcript, and
        an optimal alignment. In the latter case, explain how the path specifies
        where the spaces should go in the two strings.
        
        \problemAnswer{
             Firstly we prove that any traceback path specifies an optimal edit
             transcript. To do so we can use mathematical induction. Denote
             $E(i, j)$ as the edit transcript defined by the traceback path from
             cell $(i, j)$ back to cell $(0, 0)$ in the table. We would like to
             prove the more general result that $E(i, j)$ is an optimal
             edit transcript, which implies: 
             \begin{enumerate}
                 \item $E(i, j)$ is uses exactly $D(i, j)$ conversions, i.e. the
                 sum of number of (I)(D)(R) in $E(i, j)$, defined as $N(i, j)$
                 always equals to $D(i, j)$.
                 \item $E(i, j)$ can indeed convert $S_1[1:i]$ to $S_2[1:j]$.
             \end{enumerate}
             We prove these two points with mathematical induction:
             \begin{itemize}
                 \item Since $E(i, 0)$ is just $i$ D's, we have $N(i, 0) = i =
                 D(i, 0)$. Also, carrying out $i$ deletion to $S_1[1:i]$ results
                 in the empty string $S_2[1:0]$. On the other hand, $E(0, j)$ is
                 just $j$ I's, so $N(0, j) = j = D(0, j)$. Besides, carrying out
                 $j$ insertions to $S_1[1:0]$ apparently results in the string
                 $S_2[1:j]$.
                 \item If $E(i, j - 1)$, $E(i - 1, j)$ and $E(i-1, j-1)$ are an
                 optimal edit transcript for $(S_1[1:i],S_2[1:j-1])$,
                 $(S_1[1:i-1],S_2[1:j])$ and $(S_1[1:i-1],S_2[1:j-1])$,
                 respectively, we would like to prove that $E(i, j)$ is also an
                 optimal edit transcript for $(S_1[1:i],S_2[1:j])$:
                 \begin{enumerate}
                     \item If the pointer to cell $(i,j)$ is from cell $(i,
                     j-1)$, then we know that $D(i,j)=D(i,j-1) + 1$. According
                     to the description of how the edit transcript is derived,
                     $E(i,j) = [E(i, j-1), \mbox{I}]$. Consequently, $N(i,j) =
                     N(i, j-1) + 1 = D(i, j-1) + 1 = D(i,j)$.

                     Also, since with
                     $E(i, j-1)$ we can convert $S_1[1:i]$ to $S_2[1:j-1]$, then
                     by inserting $S_2[j]$ to the end of $S_1[1:i]$, we can
                     exactly convert $S_1[1:i]$ to $S_2[1:j]$ with $E(i,j)$.
                     \item If the pointer to cell $(i,j)$ is from cell $(i-1,
                     j)$, then we know that $D(i,j)=D(i-1,j) + 1$. According
                     to the description of how the edit transcript is derived,
                     $E(i,j) = [E(i-1, j), \mbox{D}]$. Consequently, $N(i,j) =
                     N(i-1, j) + 1 = D(i-1, j) + 1 = D(i,j)$.

                     Also, since with
                     $E(i-1, j)$ we can convert $S_1[1:i-1]$ to $S_2[1:j]$,
                     then by deleting $S_1[i]$ at the end of $S_1[1:i]$, we
                     can exactly convert $S_1[1:i]$ to $S_2[1:j]$ with $E(i,j)$.
                     \item If the pointer to cell $(i,j)$ is from cell $(i-1,
                     j-1)$, then we know that $D(i,j)=D(i-1,j-1) + t(i,j)$.
                     \begin{itemize}
                         \item If $t(i,j) = 0$, we know that $S_1[i]=S_2[j]$,
                         thus $E(i,j) = [E(i-1, j-1), \mbox{M}]$. Consequently,
                         $N(i,j) = N(i-1, j-1) = D(i-1, j-1) = D(i,j)$. Also,
                         since with $E(i-1, j-1)$ we can convert $S_1[1:i-1]$ to
                         $S_2[1:j-1]$, by appending the same character to the
                         end of $S_1[1:i-1]$ and $S_2[1:j-1]$ we can exactly
                         convert $S_1[1:i]$ to $S_2[1:j]$ with $E(i,j)$.
                         \item If $t(i,j) = 1$, we know that
                         $S_1[i]\not=S_2[j]$, thus $E(i,j) = [E(i-1, j-1),
                         \mbox{R}]$. Consequently, $N(i,j) = N(i-1, j-1) + 1 =
                         D(i-1, j-1) + 1 = D(i,j)$. Also, since with $E(i-1,
                         j-1)$ we can convert $S_1[1:i-1]$ to $S_2[1:j-1]$, by
                         replacing $S_1[i]$ with $S_2[j]$ we can exactly convert
                         $S_1[1:i]$ to $S_2[1:j]$ with $E(i,j)$.
                     \end{itemize}
                 \end{enumerate}
             \end{itemize}
             According to the mathematical induction, we have proved that any
             traceback path specifies an optimal edit transcript. From Problem
             2, such a traceback path also specifies an optimal alignment. The
             algorithm that computes the optimal alignment directly from a
             traceback is described in Algorithm~\ref{alg:tb2ali}.
             \begin{algorithm}
                \caption{Convert an optimal traceback pathc $T$ edit and the
                original strings $(S_1, S_2)$ to an optimal alignment $(S_1',
                S_2'$).}
                \label{alg:tb2ali}
                \begin{algorithmic}[1]
                    \STATE Initialize pointer $p_1$ to the beginning of
                    $S_1$, $p_2$ to the beginning of $S_2$, $t$ to the
                    beginning of $T$, and $a$ to the beginning of the alignment
                    $S_1', S_2'$.
                    \REPEAT
                        \IF {$T[t+1]$ takes a horizontal step from $T[t]$} 
                            \STATE $S_1'[a] = \_$, $S_2'[a] = S_2[p_2]$.
                            \STATE $t += 1$, $p_2 += 1$, $a += 1$.
                        \ELSIF {$T[t+1]$ takes a vertical step from $T[t]$}
                            \STATE $S_1'[a] = S_1[p_1]$, $S_2'[a] = \_$.
                            \STATE $t += 1$, $p_1 += 1$, $a += 1$.
                        \ELSE
                            \STATE $S_1'[a] = S_1[p_1]$, $S_2'[a] = S_2[p_2]$.
                            \STATE $t += 1$, $p_1 += 1$, $p_2 += 1$, $a += 1$.
                        \ENDIF
                    \UNTIL{$t$ at the end of $T$}
                \end{algorithmic}
            \end{algorithm}
        }
    \end{homeworkProblem}
    
    %----------------------------------------------------------------------------------------
    %   PROBLEM 4
    %----------------------------------------------------------------------------------------
    \begin{homeworkProblem}
        \textbf{Theorem} Any path from $(n, m)$ to $(0, 0)$ following pointers
        established during the computation of $D(i, j)$ specifies an edit
        transcript with the minimum number of edit operations. Conversely, any
        optimal edit transcript is specified by such a path. Moreover, since a
        path describes only one transcript, the correspondence between paths and
        optimal transcripts is one-one.
        
        Prove this theorem.
        
        \problemAnswer{
            The first part of the theorem, i.e. any traceback path specifies an
            optimal edit transcript, has already been proved in Problem 3. For
            the converse argument, i.e. any optimal edit transcript is specified
            by a traceback path, can also be proved with mathematical induction.
            Define the set of all traceback paths from cell $(i,j)$ to $(0,0)$ as
            $\mathcal{T}(i, j)$. We would like to show that any optimal
            transcript for $S_1[1:i]$ and $S_2[1:j]$ is specified by a path in
            $\mathcal{T}(i, j)$.
            \begin{itemize}
                \item Apparently, the only edit transcript that converts
                $S_1[1:i]$ to an empty string $S_2[1:0]$ is the one contains
                solely $i$ D's, and the corresponding $\mathcal{T}(i, 0)$
                contains only 1 path composed of only vertical steps. 
                Similarly, the only edit transcript that converts an empty
                string $S_1[1:0]$ to $S_2[1:j]$ is the one contains
                solely $i$ I's, and the corresponding $\mathcal{T}(0, j)$
                contains only 1 path composed of horizontal vertical steps.
                \item Now we assume that any optimal edit transcript $E(i,
                j-1)$, $E(i-1, j)$ and $E(i-1, j-1)$ is specified by a path in
                $\mathcal{T}(i, j-1)$, $\mathcal{T}(i-1, j)$ and
                $\mathcal{T}(i-1, j-1)$, respectively. Given an optimal edit
                transcript $E(i,j)$ of length $l$
                \begin{enumerate}
                    \item If $E(i,j)[l]=\mbox{I}$, then we know $D(i, j) =
                    D(i, j-1) + 1$, therefore $E(i,j)[1:l-1]$ is an optimal edit
                    transcript for $S_1[1:i]$ and $S_2[1:j-1]$, thus it must be
                    specified by some $t \in \mathcal{T}(i, j-1)$.
                    Correspondingly, $E(i,j)$ is specified by $[t, (i,j)]$.
                    Also, one pointer in cell $(i, j)$ must be horizontal, which means
                    $[t, (i,j)] \in \mathcal{T}(i, j)$.
                    \item If $E(i,j)[l]=\mbox{D}$, then we know $D(i, j) =
                    D(i-1, j) + 1$, therefore $E(i,j)[1:l-1]$ is an optimal
                    edit transcript for $S_1[1:i-1]$ and $S_2[1:j]$, thus it
                    must be specified by some $t \in \mathcal{T}(i-1, j)$.
                    Correspondingly, $E(i,j)$ is specified by $[t, (i,j)]$.
                    Also, one pointer in cell $(i, j)$ must be vertical, which
                    means $[t, (i,j)] \in \mathcal{T}(i, j)$.
                    \item If $E(i,j)[l]=\mbox{R}$ or M, then we know $D(i, j) =
                    D(i-1, j-1) + t(i,j)$, therefore $E(i,j)[1:l-1]$ is an
                    optimal edit transcript for $S_1[1:i-1]$ and $S_2[1:j-1]$,
                    thus it must be specified by some $t \in \mathcal{T}(i-1,
                    j-1)$. Correspondingly, $E(i,j)$ is specified by $[t,
                    (i,j)]$. Also, one pointer in cell $(i, j)$ must be
                    diagonal, which means $[t, (i,j)] \in \mathcal{T}(i, j)$.
                \end{enumerate}
            \end{itemize}
            According to mathematical induction, we have proved that any optimal
            edit transcript is specified by a traceback path. Consequently, the
            correspondence between paths and optimal transcripts is one-one.        
        }
    \end{homeworkProblem}
    
    %----------------------------------------------------------------------------------------
    %   PROBLEM 5
    %----------------------------------------------------------------------------------------
    \begin{homeworkProblem}
        Since the traceback paths in a dynamic programming table correspond
        one-to-one with the optimal alignments, the number of distinct
        co-optimal alignments can be obtained by computing the number of
        distinct traceback paths. Give an algorithm to compute this number in
        $O(nm)$ time. Hint: use dynamic programming.

        \problemAnswer{
            Define the number of distinct co-optimal alignments for $S_1[1:i]$
            and $S_2[1:j]$ to be $M(i, j)$. From the Problem 4, we can easily
            compute $M(i, j)$ with dynamic programming, as depicted in
            Algorithm~\ref{alg:countpaths}.
            \begin{algorithm}
                \caption{Compute the number of distinct co-optimal alignments
                $M(m,n)$ with dynamic programming.}
                \label{alg:countpaths}
                \begin{algorithmic}[1]
                    \STATE Compute $D(i,j)$ for $i=0,\ldots,m$ and $j,\ldots,n$
                    using DP in $\mathcal{O}(mn)$ time.
                    \STATE Initialize $M(i,0)=i$ for $i=0,\ldots,m$ and
                    $M(0,j)=j$ for $j=0,\ldots,n$.
                    \FOR {i=1 \TO m}
                        \FOR {j=1 \TO n}
                            \STATE Set $M(i,j)=0$.
                            \IF {$D(i, j) = D(i, j-1) + 1$}
                                \STATE $M(i,j)+=M(i,j-1)$.
                            \ENDIF
                            \IF {$D(i, j) = D(i-1, j) + 1$}
                                \STATE $M(i,j)+=M(i-1,j)$.
                            \ENDIF
                            \IF {$D(i, j) = D(i-1, j-1) + t(i,j)$}
                                \STATE $M(i,j)+=M(i-1,j-1)$.
                            \ENDIF
                        \ENDFOR
                    \ENDFOR
                    \RETURN $M(m, n)$
                \end{algorithmic}
            \end{algorithm}
            
        }
    \end{homeworkProblem}
    %\clearpage

    
    %----------------------------------------------------------------------------------------

\end{document}