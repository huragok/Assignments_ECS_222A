%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Structured General Purpose Assignment
% LaTeX Template
%
% This template has been downloaded from:
% http://www.latextemplates.com
%
% Original author:
% Ted Pavlic (http://www.tedpavlic.com)
%
% Note:
% The \lipsum[#] commands throughout this template generate dummy text
% to fill the template out. These commands should all be removed when 
% writing assignment content.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%----------------------------------------------------------------------------------------
%	PACKAGES AND OTHER DOCUMENT CONFIGURATIONS
%----------------------------------------------------------------------------------------

\documentclass{article}

\usepackage{fancyhdr} % Required for custom headers
\usepackage{lastpage} % Required to determine the last page for the footer
\usepackage{extramarks} % Required for headers and footers
\usepackage{graphicx} % Required to insert images
\usepackage{lipsum} % Used for inserting dummy 'Lorem ipsum' text into the template
\usepackage{amsmath}
\usepackage{xcolor}
\usepackage{listings}
\usepackage[toc,page]{appendix}
\usepackage{algorithm}
\usepackage{algorithmic}

% Margins
\topmargin=-0.45in
\evensidemargin=0in
\oddsidemargin=0in
\textwidth=6.5in
\textheight=9.0in
\headsep=0.25in 

\linespread{1.1} % Line spacing

% Set up the header and footer
\pagestyle{fancy}
\lhead{\hmwkAuthorName} % Top left header
\chead{\hmwkClass\ (\hmwkClassInstructor): \hmwkTitle} % Top center header
\rhead{\firstxmark} % Top right header
\lfoot{\lastxmark} % Bottom left footer
\cfoot{} % Bottom center footer
\rfoot{Page\ \thepage\ of\ \pageref{LastPage}} % Bottom right footer
\renewcommand\headrulewidth{0.4pt} % Size of the header rule
\renewcommand\footrulewidth{0.4pt} % Size of the footer rule

\setlength\parindent{0pt} % Removes all indentation from paragraphs

%----------------------------------------------------------------------------------------
%	DOCUMENT STRUCTURE COMMANDS
%	Skip this unless you know what you're doing
%----------------------------------------------------------------------------------------

% Header and footer for when a page split occurs within a problem environment
\newcommand{\enterProblemHeader}[1]{
    \nobreak\extramarks{#1}{#1 continued on next page\ldots}\nobreak
    \nobreak\extramarks{#1 (continued)}{#1 continued on next page\ldots}\nobreak
}

% Header and footer for when a page split occurs between problem environments
\newcommand{\exitProblemHeader}[1]{
    \nobreak\extramarks{#1 (continued)}{#1 continued on next page\ldots}\nobreak
    \nobreak\extramarks{#1}{}\nobreak
}

\setcounter{secnumdepth}{0} % Removes default section numbers
\newcounter{homeworkProblemCounter} % Creates a counter to keep track of the number of problems
\setcounter{homeworkProblemCounter}{0}

\newcommand{\homeworkProblemName}{}
\newenvironment{homeworkProblem}[1][Problem \arabic{homeworkProblemCounter}]{ % Makes a new environment called homeworkProblem which takes 1 argument (custom name) but the default is "Problem #"
    \stepcounter{homeworkProblemCounter} % Increase counter for number of
% problems
    \renewcommand{\homeworkProblemName}{#1} % Assign \homeworkProblemName the
% name of the problem
    \section{\homeworkProblemName} % Make a section in the document with the
% custom problem count
    \enterProblemHeader{\homeworkProblemName} % Header and footer within the
% environment
}{
    \exitProblemHeader{\homeworkProblemName} % Header and footer after the
% environment
}

\newcommand{\problemAnswer}[1]{ % Defines the problem answer command with the content as the only argument
    \noindent\textbf{\emph{Answer: }}#1 % Just put a keyword Answer in
    % bold/italic at the beginning
}

\newcommand{\homeworkSectionName}{}
\newenvironment{homeworkSection}[1]{ % New environment for sections within homework problems, takes 1 argument - the name of the section
    \renewcommand{\homeworkSectionName}{#1} % Assign \homeworkSectionName to the
% name of the section from the environment argument
    \subsection{\homeworkSectionName} % Make a subsection with the custom name
% of the subsection
    \enterProblemHeader{\homeworkProblemName\ [\homeworkSectionName]} % Header
% and footer within the environment
}{
    \enterProblemHeader{\homeworkProblemName} % Header and footer after the
% environment
}

\newtheorem{theorem}{Theorem}[homeworkProblemCounter]
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{corollary}[theorem]{Corollary}

\newenvironment{proof}[1][Proof]{
    \begin{trivlist}
        \item[\hskip \labelsep {\bfseries #1}]
    }{
        \end{trivlist}
}
\newenvironment{definition}[1][Definition]{
    \begin{trivlist}
        \item[\hskip \labelsep {\bfseries #1}]
    }{
        \end{trivlist}
}
\newenvironment{example}[1][Example]{
    \begin{trivlist}
        \item[\hskip \labelsep {\bfseries #1}]
    }{
        \end{trivlist}
    }
\newenvironment{remark}[1][Remark]{
    \begin{trivlist}
        \item[\hskip \labelsep {\bfseries #1}]
    }{
        \end{trivlist}
}

\newcommand{\qed}{
    \nobreak \ifvmode \relax \else
    \ifdim\lastskip<1.5em \hskip-\lastskip
    \hskip1.5em plus0em minus0.5em \fi \nobreak
    \vrule height0.75em width0.5em depth0.25em\fi
}

\lstset{
    frame=single,
    breaklines=true,
    postbreak=\raisebox{0ex}[0ex][0ex]{\ensuremath{\color{red}\hookrightarrow\space}}
}
   
%----------------------------------------------------------------------------------------
%	NAME AND CLASS SECTION
%----------------------------------------------------------------------------------------

\newcommand{\hmwkTitle}{Assignment\ \#3} % Assignment title
\newcommand{\hmwkDueDate}{Tusday,\ January\ 20,\ 2015} % Due date
\newcommand{\hmwkClass}{ECS\ 222A} % Course/class
\newcommand{\hmwkClassTime}{TR 4:40pm-6:00pm} % Class/lecture time
\newcommand{\hmwkClassInstructor}{Daniel Gusfield} % Teacher/lecturer
\newcommand{\hmwkAuthorName}{Wenhao Wu} % Your name

%----------------------------------------------------------------------------------------
%	TITLE PAGE
%----------------------------------------------------------------------------------------

\title{
    \vspace{2in}
    \textmd{\textbf{\hmwkClass:\ \hmwkTitle}}\\
    \normalsize\vspace{0.1in}\small{Due\ on\ \hmwkDueDate}\\
    \vspace{0.1in}\large{\textit{\hmwkClassInstructor\ \hmwkClassTime}}
    \vspace{3in}
}

\author{\textbf{\hmwkAuthorName}}
\date{} % Insert date here if you want it to appear below your name

%----------------------------------------------------------------------------------------

\begin{document}

    \maketitle
    
    %----------------------------------------------------------------------------------------
    %	TABLE OF CONTENTS
    %----------------------------------------------------------------------------------------
    
    %\setcounter{tocdepth}{1} % Uncomment this line if you don't want subsections listed in the ToC
    
    \newpage
    \tableofcontents
    \newpage

    %----------------------------------------------------------------------------------------
    %	PROBLEM 1
    %----------------------------------------------------------------------------------------
    \begin{homeworkProblem}
        The secondary structure problem discussed in section 6.5 in the book
        seeks to find the secondary structure that maximizes the number of base
        pairs it contains, i.e. the number of pairs that are in the matching (or
        pairing). Review the definitions of ``secondary structure'' on page 274
        in the book. In class, we used the term ``non-crossing pairing'' for
        what the book calls a ``secondary structure''.
        \\\\
        Now suppose that instead of wanting to find the the secondary structure
        maximizing the number of pairs it contains, we want to \emph{count} the
        exact \emph{number} of distinct secondary structures possible in a given
        RNA sequence. Some of these secondary structures will not contain the
        largest number of pairs possible.
        \\\\
        For example, in the RNA molecule ACGGGUGU there are five secondary
        structures. One contains no pairs (hey, its a legal secondary structure
        according to the definition); one pairs the A to the farthest U; one
        that pairs the A to closest U; one pairs the C to the farthest G; and
        one pairs the A to the farthest U, and the C to the farthest G.
        \\\\
        This counting problem can be solved by DP.
        
        \begin{homeworkSection}{\homeworkProblemName(a)}
            Write recurrence relations that give the solution to the counting
            problem.
            \\\\
            Hint: You may be tempted to just do a simple conversion of the
            recurrences we used in class to find the maximum number of pairs in
            a non-crossing pairing (secondary structure), but you need to be
            careful. The reason, is that the cases in the recurrences we used in
            class were not disjoint. That is, the same secondary structure might
            arise by more than one case in the recurrences. Since we were taking
            the Max over all the cases, it did not matter if the same secondary
            structure arose different ways. But now that we want to count the
            number of distinct secondary structures, we have to be more careful.
            Define $N(i, j)$ as the number of secondary structures involving the
            positions from $i$ to $j$ inclusive. It includes the empty matching
            as one of the matchings. For technical reasons, you may want to
            define define $N(j, j) = N$ and $N(j + 1, j) = 1$. The problem asks
            you to write recurrences for $N(i, j)$.
            \\\\
            Be sure to explain why your recurrences give a correct recursive
            solution for the problem of counting the number of secondary
            structures.
            \vspace{10pt}
            
            \problemAnswer{
                Consider all the secondary structures on the inclusive interval
                $(i, j)$:
                \begin{itemize}
                    \item The number of secondary structures in which element
                    $j$ is not paired with any element in $(i, j-1)$ is the same
                    as the number of secondary structures on $(i, j-1)$, i.e.
                    \[
                        N_1(i, j) = N(i, j-1)
                    \]
                    \item If element $j$ can be paired with some element $k\in
                    (i, j-1)$, indicated by $\beta(k, j) = 1$, then any
                    secondary structure on $(i, k-1)$ and any secondary
                    structure on $(k+1, j-1)$, together with the pair formed
                    by element $k$ and $j$, forms a distinct secondary structure
                    on $(i,j)$ that is not included in the previous case.
                    Consequently, the number of these secondary structures is
                    \[
                        N_{2,k}(i, j) = \left\{\begin{array}{ll}N(i, k-1)N(k+1,
                        j-1), & \mbox{if } \beta(k, j) = 1\\ 0, &
                        \mbox{else}\end{array}\right.
                    \]
                \end{itemize}
                These 2 cases exhaust all distinct secondary structures,
                therefore the recurrence of counting is
                \begin{align*}
                    N(i, j) & = N_1(i, j) + \sum_{k=i}^{j-1}N_{2,k}(i, j) \\
                            & = N(i, j-1) + \sum_{\substack{k=i \\
                            \beta(k,j) = 1}}^{j-1}N(i, k-1)N(k+1,j-1)
                \end{align*}
                And the base cases are (according to the definition on the
                textbook and the example given here, no sharp turns)
                \[
                    N(j, j+m) = 1,\;m=-1,0,1,2,3,4.
                \]
                In these cases the only secondary structure is no pairing at
                all.
            }
        \end{homeworkSection}
        
        \begin{homeworkSection}{\homeworkProblemName(b)}
            As before, instead of using the recurrences in a top-down recursive
            algorithm, we want to use them in a DP solution to the problem.
            \\\\
            Write out the pseudo-code for a DP solution to the counting problem,
            and analyze the worst-case running time of the DP solution.
            \vspace{10pt}
            
            \problemAnswer{
                The pseudo-code for a DP solution is given in
                Algorithm~\ref{alg:count_secondary_structure}.
                \begin{algorithm}
                    \caption{Count the number of secondary structures in a RNA
                    string.}
                    \label{alg:count_secondary_structure}
                    \begin{algorithmic}[1]
                        \STATE Initialize $N(j, j+m) = 1$ for $m=-1,0,1,2,3,4$,
                        $j = 1, \ldots, n$.
                        \FOR {$m=1$ \TO $n - 1$}
                            \FOR {$i=1$ \TO $n$}
                                \STATE Compute and save
                                \[
                                    N(i, i+m) = N(i, i+m-1) +
                                    \sum_{\substack{k=i \\ \beta(k,i+m) =
                                    1}}^{i+m-1} N(i, k-1)N(k+1,i+m-1)
                                \]
                            \ENDFOR
                        \ENDFOR
                        \RETURN $N(1, m)$.
                    \end{algorithmic}
                \end{algorithm}
                There are $O(n^2)$ $N(i, j)$ terms in the DP table to fill in.
                To fill in each term using the recurrence equation requires
                $O(n)$ multiplication, addition and table lookup (RAM model).
                Consequently, the worst-case running time of the DP solution is
                $O(n^3)$.
            }
        \end{homeworkSection}
    \end{homeworkProblem}
    
    %----------------------------------------------------------------------------------------
    %   PROBLEM 2
    %----------------------------------------------------------------------------------------
    \begin{homeworkProblem}
        Suppose we are given a rooted tree $T$ with $n$ leaves and $m$ non-leaf
        nodes. Each leaf is colored with one of $k < n$ given colors, so several
        leaves can have the same color. We need to color each interior node of T
        with one of the $k$ given colors to \emph{maximize} the number of edges
        whose (two) endpoints are colored the same color.
        \\\\
        We can solve this with a DP algorithm that runs in $O(mk)$ time. Let
        $V(v, i)$ denote the optimal solution value when the problem is applied
        to the subtree rooted at node $v$, and $v$ is required to be given color
        $i$. Let $V(v)$ denote the optimal solution value when the problem is
        applied to the subtree rooted at node $v$, and there is no restriction
        on which of the $k$ colors $v$ can be.
        \begin{homeworkSection}{\homeworkProblemName(a)}
            Using that notation, develop recurrences for this problem, and
            explain the correctness of your recurrences.
            \vspace{10pt}
            
            \problemAnswer{
                Denote the set of leaf children and non-leaf children of node
                $v$ as $v.C_l$ and $v.C_{nl}$, respectively. Denote indicator
                function $\delta(i, j) = 1$ if $i=j$ and 0 otherwise, where
                $i,j=1,\ldots,k$. Denote the color of a leaf node $l$ as
                $l.color$. Then we have
                \begin{align*}
                    V(v, i) = \sum_{l\in v.C_l}\delta(i, l.color) + \sum_{n\in
                    v.C_{nl}}\left[\max_{j=1,\ldots,k}(V(n,
                    j)+\delta(i,j))\right]
                \end{align*}
                Here is an explanation for this recurrence:
                \begin{itemize}
                    \item For the 1st term in the RHS, node $v$ forms a
                    same-color edge with any leaf nodes with color $i$.
                    \item For the 2nd term in the RHS, given a non-leaf child
                    $n$ of $v$, if $n$ is in color $j$, then the tree from $n$
                    contains $V(n,j)$ edges. $n$ and $v$ also forms another
                    same-color edge if and only if $i=j$. To maximize the number
                    of edges, color $j$ should be determined by maximizing the
                    possible number of edges brought by setting $n$'s color to
                    $j$.
                \end{itemize}
                Note that with this recurrence we don't need to explicitly
                define a base case. The solution to the original problem, is
                simply $\max_{i=1,\ldots,k}V(T.root, i)$. To determine an
                optimal coloring scheme, each non-leaf, non-root node $v$
                maintains an array $v.j(i), i=1,\ldots,k$ which means the
                optimal color $j$ that $v$ should use when $v.parent$ is colored
                with $i$. The starting point for this traceback is the optimal
                color for $T.root$.
            }
        \end{homeworkSection}
        
        \begin{homeworkSection}{\homeworkProblemName(b)}
            Expalin how the recurrences are evaluated (solved) in an efficient
            DP way.
            \vspace{10pt}
            
            \problemAnswer{
                The pseudo-code for a DP solution is given in
                Algorithm~\ref{alg:count_edges}.
                \begin{algorithm}
                    \caption{Count the number of maximum same-color edges.}
                    \label{alg:count_edges}
                    \begin{algorithmic}[1]
                        \STATE Order the non-lear nodes in tree $T$ into a heap
                        $H$, i.e. put each node into a queue in the same order
                        as in a BFS but perform no dequeueing. This can be done
                        in $O(m)$.
                        \FOR {$l = m$ : $l>=1$: $l--$}
                            \STATE Compute and save
                            \[
                                V(h[m], i) = \sum_{l\in h[m].C_l}\delta(i, l.color)
                                + \sum_{n\in h[m].C_{nl}}\left[\max_{j=1,\ldots,k}(V(n,
                    j)+\delta(i,j))\right],\;i=1,\ldots,k
                            \]
                            and record $n.j(i) =
                            \arg\max_{j=1,\ldots,k}(V(n,j)+\delta(i,j))$, $i =
                            1,\ldots,k$ for all $n\in h[m].C_{nl}$.
                        \ENDFOR
                        \STATE $T.root$, i.e. $H[1]$ is colored optimally with
                        $T.root.color_{opt}
                        = \arg\max_{j=1,\ldots,k}V(T.root,j)$. Then traceback
                        and color each node $v$ with $v.color_{opt} =
                        v.j(v.parent.color_{opt})$. Either a BFS or DFS will do
                        in $O(m)$ time (RAM model).
                        \RETURN the maximal number of edges
                        $\max_{j=1,\ldots,k}V(T.root,j)$.
                    \end{algorithmic}
                \end{algorithm}
                
            }
        \end{homeworkSection}
        
        \begin{homeworkSection}{\homeworkProblemName(c)}
            Show that the time bound for your DP is $O(mk)$.
            \vspace{10pt}
            
            \problemAnswer{
                There are $mk$ $V(v, i)$ and $v.j(i)$ to compute respectively.
                On computing each $V(v, i)$ or $v.j(i)$, the maximization over
                all $k$ different colors is performed. Also we assume that each
                node has a finite degree, so the total cost of summation over
                the leaf nodes and non-leaf nodes is also $O(m)$. Consequently,
                the time bound for this DP is $O(mk^2)$.
                
            }
        \end{homeworkSection}
    \end{homeworkProblem}
    
    %----------------------------------------------------------------------------------------
    %   PROBLEM 3
    %----------------------------------------------------------------------------------------
    \begin{homeworkProblem}
        In the sequence alignment problem, suppose now we want to compute the
        number of optimal alignments that align character $i$ with character
        $j$, or align character $i$ with a space, for each pair $(i, j)$. Show
        how to compute this via DP in $O(nm)$ time.
        \\\\
        Hint: You might be able to extend your answer to Problem 5 in HW 2.
        \vspace{10pt}
        
        \problemAnswer{
            Firstly we introduce a few notations:
            \begin{itemize}
                \item $P(i, j)$: the minimum number of edit operations to
                transform $S_1$ to $S_2$, in which $S_1[i]$ is aligned to
                $S_2[j]$.
                \item $Q(i)$: the minimum number of edit operations to
                transform $S_1$ to $S_2$, in which $S_1[i]$ is aligned to
                $S_2[j]$.
                \item $R(i, j)$: the minimum number of edit operations to
                transform $S_1$ to $S_2$, in which $S_1[i]$ is aligned to
                $S_2[j]$ or deleted, i.e.
                \begin{align}
                    R(i, j) = \min\{P(i, j), Q(i)\} \label{eq:Rij}
                \end{align}
                \item $D(i, j)$: the minimum number of edit operations to
                transform $S_1[1:i]$ to $S_2[1:j]$.
                \item $E(i, j)$: the minimum number of edit operations to
                transform $S_1[i:m]$ to $S_2[j:n]$.
                \item $M(i, j)$: the number of optimal alignments between
                $S_1[1:i]$ to $S_2[1:j]$. This is the variable we defined in
                Probelm 5, HW2.
                \item $N(i, j)$: the number of optimal alignments between
                $S_1[i:m]$ to $S_2[j:n]$.
                \item $L(i)$: the number of optimal alignments between $S_1$ and
                $S_2$, in which $S_1[i]$ is deleted.
                \item $K(i, j)$: the number of optimal alignments that align
                $S_1[i]$ to $S_2[j]$, or align $S_1[i]$ with a space (i.e.
                $S_1[i]$ is deleted).
            \end{itemize}
            To compute all $K(i, j)$, we would like to make use of the following
            facts:
            \begin{itemize}
                \item For an optimal alignments where $S_1[i]$ is aligned to
                $S_2[j]$, $S_1[1 : i-1]$ must be optimally aligned to
                $S_2[1 : j-1]$, and $S_1[i+1 : m]$ must be optimally aligned to
                $S_2[j+1 : n]$. Consequently,
                \begin{align}
                    P(i, j) = D(i-1, j-1) + E(i + 1, j + 1) + t(i, j).
                    \label{eq:Pij}
                \end{align}
                And the total number of this kind of alignments, i.e. the total
                number of combination of an optimal alignment between $S_1[1 :
                i-1]$ and $S_2[1 : j-1]$ and an optimal alignment between
                $S_1[i+1:m]$ and $S_2[j+1:n]$, is simply $M(i-1,
                j-1)N(i+1,j+1)$.
                \item For an optimal alignments where $S_1[i]$ is deleted, there
                must exist some $k\in\{0,\ldots,n\}$ such that $S_1[1 : i-1]$ is
                optimally aligned to $S_2[1:k]$ and $S_1[i+1:m]$ is optimally
                aligned to $S_2[k+1:n]$. Such $k$'s are determined so that the
                total number of operation is minimized. Consequently,
                \begin{align}
                    Q(i) = \min_{k=0,\ldots,n}(D(i-1,k) + E(i+1,k+1) + 1).
                    \label{eq:Qi}
                \end{align}
                And the total number of this kind of alignments, i.e. the total
                number of combination of an optimal alignment between $S_1[1 :
                i-1]$ and $S_2[1:k]$ and an optimal alignment between
                $S_1[i+1:m]$ and $S_2[k+1:n]$ for all feasible $k$, is simply      
                \begin{align}
                    L(i) = \sum_{\substack{ k=0, \\ Q(i) = D(i-1,k) + E(i+1,k+1)
                    + 1}}^nM(i-1, k)N(i+1,k+1). \label{eq:Li}
                \end{align}
                \item $D(i,j)$ and $E(i,j)$ have very similar recurrent
                structure, which is given in the class:
                \begin{align}
                    & D(i,j) = \min\{D(i-1,j)+1, D(i,j-1)+1, D(i-1,j-1)+t(i,j)\}
                    \label{eq:Dij}
                    \\
                    & D(i,0)=i, D(0,j)=j \label{eq:Dij_base}
                \end{align}
                \begin{align}
                    & E(i,j) = \min\{E(i+1,j)+1, E(i,j+1)+1, E(i+1,j+1)+t(i,j)\}
                    \label{eq:Eij}
                    \\
                    & E(i,n+1)=m-i+1, E(m+1,j)=n-j+1 \label{eq:Eij_base}
                \end{align}
                \item Similarly, $M(i,j)$ and $N(i,j)$ have very similar
                recurrent structure, which we have analyzed in Problem 5 HW2:
                \begin{align}
                    M(i, j) & = M(i, j-1)\delta(D(i,j), D(i,j-1)+1) +
                    M(i-1,j)\delta(D(i,j), D(i-1,j)+1) \notag\\
                    & + M(i-1,
                    j-1)\delta(D(i,j), D(i-1,j-1)+t(i,j)) \label{eq:Mij} \\
                    M(i,0) & = M(0,j) = 1 \label{eq:Mij_base}
                \end{align}
                \begin{align}
                    N(i, j) & = N(i, j+1)\delta(E(i,j), E(i,j+1)+1) +
                    N(i+1,j)\delta(E(i,j), E(i+1,j)+1) \notag\\
                    & + N(i+1,
                    j+1)\delta(E(i,j), E(i+1,j+1)+t(i,j)) \label{eq:Nij}\\
                    N(i,n+1) & = N(m+1,j) = 1 \label{eq:Nij_base}
                \end{align}
                where $\delta(x,y) = 1$ if $x=y$ and $\delta(x,y) = 0$
                otherwise.
                \item Once $P(i,j)$, $Q(i)$, $R(i,j)$, $M(i,j)$, $N(i,j)$ and $L(i)$
                are available, $K(i, j)$ can be simply computed as
                \begin{align}
                    K(i,j)=L(i)\delta(R(i,j), Q(i)) +
                    M(i-1,j-1)N(i+1,j+1)\delta(R(i,j), P(i,j)) \label{eq:Kij}
                \end{align}
                Namely, if deleting $S_1[i]$ results in the optimal alignments, we
                count all this kind of optimal alignments; if aligning $S_1[i]$ with
                $S_2[j]$ results in the optimal alignments, we count all this kind
                of optimal alignments.
            \end{itemize}
            The overall DP algorithm to compute all $K(i,j)$ is given in
            Algorithm~\ref{alg:count_align}.
            \begin{algorithm}
                \caption{Compute $K(i,j)$: the number of optimal alignments that
                align $S_1[i]$ to $S_1[j]$ or delete $S_1[i]$ for
                $i=1,\ldots,m$ and $j=1\ldots,n$.}
                \label{alg:count_align}
                \begin{algorithmic}[1]
                    \STATE Compute all $D(i, j)$ and $M(i, j)$ with DP following
                    the recurrence
                    Eq.~(\ref{eq:Dij})(\ref{eq:Dij_base})(\ref{eq:Mij})(\ref{eq:Mij_base}).
                    This algorithm has already been defined in the class and in
                    HW2.
                    \STATE Compute all $E(i, j)$ and $N(i, j)$ with DP following
                    the recurrence
                    Eq.~(\ref{eq:Eij})(\ref{eq:Eij_base})(\ref{eq:Nij})(\ref{eq:Nij_base}).
                    This algorithm is very similar to the one that computes all
                    $D(i, j)$ and $M(i, j)$ and a description is thus
                    omitted.
                    \STATE Given all $D(i,j)$ and $E(i,j)$, compute all
                    $P(i,j)$, $Q(i)$ and then $R(i,j)$ with
                    Eq.~(\ref{eq:Pij})(\ref{eq:Qi})(\ref{eq:Rij}), respectively.
                    \STATE Given all $M(i,j)$, $N(i,j)$, $D(i,j)$, $E(i,j)$ and
                    $Q(i)$, compute all $L(i)$ with Eq.~(\ref{eq:Li}).
                    \RETURN all $K(i,j)$ computed with Eq.~(\ref{eq:Kij}).
                \end{algorithmic}
            \end{algorithm}
            The 2 DP algorithm in line 1 and line 2 has $O(nm)$
            complexity. The computation of $nm$ $P(i,j)$, $R(i,j)$ and $m$
            $L(i)$, $Q(i)$ each have $O(nm)$ complexity. Finally, the
            computation of all $K(i,j)$ also have $O(nm)$ complexity.
            Consequently, Algorithm~\ref{alg:count_align} has $O(nm)$
            complexity.
        }
    \end{homeworkProblem}
    %\clearpage
    
    %----------------------------------------------------------------------------------------
    %   PROBLEM 4
    %----------------------------------------------------------------------------------------
    \begin{homeworkProblem}
        Here is another Four-Russian’s approach to doing bit-matrix
        multiplication of $A \times B = C$. Assume that $A$ and $B$ are both
        of dimension n × n. Instead of doing the preprocessing of $B$ (which is
        how the Four Russians for bit-matrix mult. was done in class), we will
        preprocess $A$. Suppose $A$ is dimension $n \times n$, and $n$ is a
        multiple of $q$ (to be set later). We partition $A$ into squares of
        dimension $q \times q$. So there are $n^2 / q^2$ of these squares, and
        they are indexed by $(s, t)$ where $s$ and $t$ both range from 1 to
        $n/q$. For each pair $(s, t)$, build a table of size $2^q$, one cell for
        each possible binary number of length $q$. The cells in that table are
        indexed by the binary numbers 0 through $2^q - 1$. For the cell in the
        $(s, t)$ table, indexed by binary number $b$, compute the bit-matrix
        multiplication of square $(s, t)$ times $b$. The result is a vector of
        length $q$. That is the preprocessing for $A$.
        
        \begin{homeworkSection}{\homeworkProblemName(a)}
            In the RAM model, we can follow a pointer, or use an index, or
            lookup a value, or take the OR of two vectors in constant time,
            provided that each pointer, index, value or vector only uses $\log
            m$ bits, where $m$ is the number of bits used to represent the
            input. In our case, $m$ is $n^2$. However, the bit-matrix
            multiplication of two vectors of size $q$, takes time $q$. How much
            time does the preprocessing of $A$ take in the RAM model?
            \vspace{10pt}
            
            \problemAnswer{
                There are $n^2/q^2$ tables to build. To process the $(s,t)$-th
                table $T_{s,t}$ alone, we need to compute $2^q$ multiplications
                between a $q$-by-$q$ matrix and a $q$-by-$1$ vector. Each
                matrix-vector multiplication compose of $q$ vector-vector
                multiplication which takes time $q$. In summary, the
                preprocessing of $A$ takes
                \[
                    t_A = \frac{n^2}{q^2}\cdot 2^q\cdot q\cdot q = n^22^q.
                \]
                
            }
        \end{homeworkSection}
        
        \begin{homeworkSection}{\homeworkProblemName(b)}
            After preprocessing of $A$, we want to compute $A \times B$. We will
            view that as n multiplication $A \times B_j$, where $B_j$ is the $j$
            column of $B$, and where $j$ ranges from 1 to $n$. That is, the $j$
            column of $C$ is $A$ times the $j$ column of $B$.
            \\\\
            To do multiplication $A \times B_j = C_j$, we divide $B_j$ and $C_j$
            into $n/q$ groups of size $q$ each.
            \\\\
            Explain how to use the preprocessed tables to compute the first
            group of size $q$ of $C_j$.
            \vspace{10pt}
            
            \problemAnswer{
                Denote the $(s,t)$-th $q$-by-$q$ block in $A$ as $A(s, t)$.
                Denote the $t$-th group of size $q$ in $B_j$, $C_j$ as $B_j(t)$,
                $C_j(t)$, respectively. We have
                \[
                    C_j(1) = \sum_{t=1}^{n/q}A(1, t)B_j(t)
                \]
                in which $A(1, t)B_j(t)$ is the $B_j(t)$-th element in the $(1,
                t)$-th table $T_{1,t}$. In summary, we only need to look up
                $T_{1,t}[B_j(t)]$ for $t=1,\ldots,n/q$, and then perform $n/q -
                1$ vector summation of size $q$ to compute the first group of
                size $q$ of $C_j$.
            }
        \end{homeworkSection}
        
        \begin{homeworkSection}{\homeworkProblemName(c)}
            Estimate the total time needed to compute $C_j$, using the
            preprocessed tables, under the RAM model.
            \vspace{10pt}
            
            \problemAnswer{
                As analyzed in the previous problem, to compute each group of
                size $q$ $C_j(s)$, $s=1,\ldots,n/q$, we need to perform $n/q$
                table look-up and $n/q - 1$ vector summation. In RAM model, both
                the table-look-up and vector-OR operation takes constant time.
                Consequently, the time to compute $C_j$ is
                \[
                    t_{C_j} = O\left(\frac{n}{q}\cdot\frac{n}{q}\right) =
                    O\left(\frac{n^2}{q^2}\right).
                \]
            
            }
        \end{homeworkSection}
        
        \begin{homeworkSection}{\homeworkProblemName(d)}
            Show that this approach can compute the bit-matrix multiplication in
            $O(n^3 /\log n)$, by picking $q$ to be $\epsilon \log n$, for any
            $\epsilon > 1$.
            \vspace{10pt}
            
            \problemAnswer{
                Since all $C_j$ where $j=1,\ldots,n$ needs to be computed,
                taking into account of the cost to preprocess $A$, the total
                amount of time to compute $C$ is:
                \begin{align*}
                    t_C & = t_A + nt_{C_j} = O\left(n^22^q +
                    \frac{n^3}{q^2}\right) \notag\\
                    & = O\left(n^{2+\epsilon} +\frac{n^3}{\epsilon^2\log^2
                    n}\right)
                    \notag
                    \\
                    & = O\left(\frac{n^3}{\log^2 n}\right).
                \end{align*}
            
            }
        \end{homeworkSection}
    \end{homeworkProblem}
    %\clearpage
    
    %----------------------------------------------------------------------------------------

\end{document}